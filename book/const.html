
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>Const Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.0.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="freeapplicative.html" />
    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="typeclasses.html">
            
                <a href="typeclasses.html">
            
                    
                    Typeclasses
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="applicative.html">
            
                <a href="applicative.html">
            
                    
                    Applicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="apply.html">
            
                <a href="apply.html">
            
                    
                    Apply
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="contravariant.html">
            
                <a href="contravariant.html">
            
                    
                    Contravariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    Faq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="foldable.html">
            
                <a href="foldable.html">
            
                    
                    Foldable
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="functor.html">
            
                <a href="functor.html">
            
                    
                    Functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="id.html">
            
                <a href="id.html">
            
                    
                    Id
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="invariant.html">
            
                <a href="invariant.html">
            
                    
                    Invariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="monad.html">
            
                <a href="monad.html">
            
                    
                    Monad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="monadcombine.md">
            
                <a href="monadcombine.md">
            
                    
                    Monadcombine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="monadfilter.md">
            
                <a href="monadfilter.md">
            
                    
                    Monadfilter
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="monoid.html">
            
                <a href="monoid.html">
            
                    
                    Monoid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="monoidk.md">
            
                <a href="monoidk.md">
            
                    
                    Monoidk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="semigroup.html">
            
                <a href="semigroup.html">
            
                    
                    Semigroup
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="semigroupk.html">
            
                <a href="semigroupk.html">
            
                    
                    Semigroupk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="show.md">
            
                <a href="show.md">
            
                    
                    Show
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="traverse.html">
            
                <a href="traverse.html">
            
                    
                    Traverse
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Data Types
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.3.1" data-path="const.html">
            
                <a href="const.html">
            
                    
                    Const
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="freeapplicative.html">
            
                <a href="freeapplicative.html">
            
                    
                    Freeapplicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="freemonad.html">
            
                <a href="freemonad.html">
            
                    
                    Freemonad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="kleisli.html">
            
                <a href="kleisli.html">
            
                    
                    Kleisli
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="oneand.html">
            
                <a href="oneand.html">
            
                    
                    Oneand
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="optiont.html">
            
                <a href="optiont.html">
            
                    
                    Optiont
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="state.html">
            
                <a href="state.html">
            
                    
                    State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="validated.html">
            
                <a href="validated.html">
            
                    
                    Validated
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="xor.html">
            
                <a href="xor.html">
            
                    
                    Xor
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="CONTRIBUTING.html">
            
                <a href="CONTRIBUTING.html">
            
                    
                    Contributing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="PROCESS.html">
            
                <a href="PROCESS.html">
            
                    
                    Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="AUTHORS.html">
            
                <a href="AUTHORS.html">
            
                    
                    Authors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="CHANGES.html">
            
                <a href="CHANGES.html">
            
                    
                    Changes
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Const</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="const">Const</h1>
<p>At first glance <code>Const</code> seems like a strange data type - it has two type parameters, yet only
stores a value of the first type. What possible use is it? As it turns out, it does
have its uses, which serve as a nice example of the consistency and elegance of functional programming.</p>
<h2 id="thinking-about-const">Thinking about <code>Const</code></h2>
<p>The <code>Const</code> data type can be thought of similarly to the <code>const</code> function, but as a data type.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">const</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">A</span>)(b: =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">A</span> = a
</code></pre>
<p>The <code>const</code> function takes two arguments and simply returns the first argument, ignoring the second.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Const</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](<span class="hljs-params">getConst: <span class="hljs-type">A</span></span>)</span>
</code></pre>
<p>The <code>Const</code> data type takes two type parameters, but only ever stores a value of the first type parameter.
Because the second type parameter is not used in the data type, the type parameter is referred to as a
&quot;phantom type&quot;.</p>
<h2 id="why-do-we-care">Why do we care?</h2>
<p>It would seem <code>Const</code> gives us no benefit over a data type that would simply not have the second type parameter.
However, while we don&apos;t directly use the second type parameter, it&apos;s existence becomes useful in certain contexts.</p>
<h3 id="example-1-lens">Example 1: Lens</h3>
<p>The following is heavily inspired by <a href="https://github.com/julien-truffaut" _target="blank">Julien Truffaut</a>&apos;s
<a href="http://functional-wizardry.blogspot.co.uk/2014/02/lens-implementation-part-1.html" _target="blank">blog post</a> on
<a href="https://github.com/julien-truffaut/Monocle" _target="blank">Monocle</a>, a fully-fledged optics library in Scala.</p>
<p>Types that contain other types are common across many programming paradigms. It is of course desirable in many
cases to get out members of other types, or to set them. In traditional object-oriented programming this is
handled by getter and setter methods on the outer object. In functional programming, a popular solution is
to use a lens.</p>
<p>A lens can be thought of as a first class getter/setter. A <code>Lens[S, A]</code> is a data type that knows how to get
an <code>A</code> out of an <code>S</code>, or set an <code>A</code> in an <code>S</code>.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>(s: <span class="hljs-type">S</span>): <span class="hljs-type">A</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">S</span>, a: <span class="hljs-type">A</span>): <span class="hljs-type">S</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">S</span> =
    set(s, f(get(s)))
}
</code></pre>
<p>It can be useful to have effectful modifications as well - perhaps our modification can fail (<code>Option</code>) or
can return several values (<code>List</code>).</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>(s: <span class="hljs-type">S</span>): <span class="hljs-type">A</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">S</span>, a: <span class="hljs-type">A</span>): <span class="hljs-type">S</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">S</span> =
    set(s, f(get(s)))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyOption</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">S</span>] =
    f(get(s)).map(a =&gt; set(s, a))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyList</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">List</span>[<span class="hljs-type">S</span>] =
    f(get(s)).map(a =&gt; set(s, a))
}
</code></pre>
<p>Note that both <code>modifyOption</code> and <code>modifyList</code> share the <em>exact</em> same implementation. If we look closely, the
only thing we need is a <code>map</code> operation on the data type. Being good functional programmers, we abstract.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Functor</span>
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>(s: <span class="hljs-type">S</span>): <span class="hljs-type">A</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">S</span>, a: <span class="hljs-type">A</span>): <span class="hljs-type">S</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">S</span> =
    set(s, f(get(s)))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyF</span></span>[<span class="hljs-type">F</span>[_] : <span class="hljs-type">Functor</span>](s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">S</span>] =
    f(get(s)).map(a =&gt; set(s, a))
}
</code></pre>
<p>We can redefine <code>modify</code> in terms of <code>modifyF</code> by using <code>cats.Id</code>. We can also treat <code>set</code> as a modification
that simply ignores the current value. Due to these modifications however, we must leave <code>modifyF</code> abstract
since having it defined in terms of <code>set</code> would lead to infinite circular calls.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Id</span>

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyF</span></span>[<span class="hljs-type">F</span>[_] : <span class="hljs-type">Functor</span>](s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">S</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">S</span>, a: <span class="hljs-type">A</span>): <span class="hljs-type">S</span> = modify(s)(_ =&gt; a)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">S</span> = modifyF[<span class="hljs-type">Id</span>](s)(f)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>(s: <span class="hljs-type">S</span>): <span class="hljs-type">A</span>
}
</code></pre>
<p>What about <code>get</code>? Certainly we can&apos;t define <code>get</code> in terms of the others.. the others are to modify an existing
value, whereas <code>get</code> is to retrieve it. Let&apos;s give it a shot anyways.</p>
<p>Looking at <code>modifyF</code>, we have an <code>S</code> we can pass in. The tricky part will be the <code>A =&gt; F[A]</code>, and then somehow
getting an <code>A</code> out of <code>F[S]</code>. If we imagine <code>F</code> to be a type-level constant function however, we could imagine
it would simply take any type and return some other constant type, an <code>A</code> perhaps. This suggests our <code>F</code> is a
<code>Const</code>.</p>
<p>We then take a look at the fact that <code>modifyF</code> takes an <code>F[_]</code>, a type constructor that takes a single type parameter.
<code>Const</code> takes two, so we must fix one. The function returns an <code>F[S]</code>, but we want an <code>A</code>, which implies we
have the first type parameter fixed to <code>A</code> and leave the second one free for the function to fill in as it wants.</p>
<p>Substituting in <code>Const[A, _]</code> wherever we see <code>F[_]</code>, the function wants an <code>A =&gt; Const[A, A]</code> and will give us back
a <code>Const[A, S]</code>. Looking at the definition of <code>Const</code>, we see that we only ever have a value of the first type parameter
and completely ignore the second. Therefore, we can treat any <code>Const[X, Y]</code> value as equivalent to <code>X</code> (plus or minus
some wrapping into <code>Const</code>). This leaves us with needing a function <code>A =&gt; A</code>. Given the type, the only thing we can do
is to take an <code>A</code> and return it right back (lifted into <code>Const</code>).</p>
<p>Before we plug and play however, note that <code>modifyF</code> has a <code>Functor</code> constraint on <code>F[_]</code>. This means we need to
define a <code>Functor</code> instance for <code>Const</code>, where the first type parameter is fixed.</p>
<p><em>Note</em>: the example below assumes usage of the <a href="https://github.com/non/kind-projector" _target="blank">kind-projector compiler plugin</a> and will not compile if it is not being used in a project.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Const</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constFunctor</span></span>[<span class="hljs-type">X</span>]: <span class="hljs-type">Functor</span>[<span class="hljs-type">Const</span>[<span class="hljs-type">X</span>, ?]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Functor</span>[<span class="hljs-type">Const</span>[<span class="hljs-type">X</span>, ?]] {
    <span class="hljs-comment">// Recall Const[X, A] ~= X, so the function is not of any use to us</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">Const</span>[<span class="hljs-type">X</span>, <span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">Const</span>[<span class="hljs-type">X</span>, <span class="hljs-type">B</span>] =
      <span class="hljs-type">Const</span>(fa.getConst)
  }
</code></pre>
<p>Now that that&apos;s taken care of, let&apos;s substitute and see what happens.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Lens</span>[<span class="hljs-type">S</span>, <span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modifyF</span></span>[<span class="hljs-type">F</span>[_] : <span class="hljs-type">Functor</span>](s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">S</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">S</span>, a: <span class="hljs-type">A</span>): <span class="hljs-type">S</span> = modify(s)(_ =&gt; a)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span></span>(s: <span class="hljs-type">S</span>)(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">S</span> = modifyF[<span class="hljs-type">Id</span>](s)(f)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>(s: <span class="hljs-type">S</span>): <span class="hljs-type">A</span> = {
    <span class="hljs-keyword">val</span> storedValue = modifyF[<span class="hljs-type">Const</span>[<span class="hljs-type">A</span>, ?]](s)(a =&gt; <span class="hljs-type">Const</span>(a))
    storedValue.getConst
  }
}
</code></pre>
<p>It works! We get a <code>Const[A, S]</code> out on the other side, and we simply just retrieve the <code>A</code> value stored inside.</p>
<p>What&apos;s going on here? We can treat the effectful &quot;modification&quot; we are doing as a store operation - we take an <code>A</code>
and store it inside a <code>Const</code>. Knowing only <code>F[_]</code> has a <code>Functor</code> instance, it can only <code>map</code> over the <code>Const</code>
which will do nothing to the stored value. After <code>modifyF</code> is done getting the new <code>S</code>, we retrieve the stored <code>A</code>
value and we&apos;re done!</p>
<h3 id="example-2-traverse">Example 2: Traverse</h3>
<p>In the popular <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf" _target="blank">The Essence of the Iterator Pattern</a>
paper, Jeremy Gibbons and Bruno C. d. S. Oliveria describe a functional approach to iterating over a collection of
data. Among the abstractions presented are <code>Foldable</code> and <code>Traverse</code>, replicated below (also available in Cats).</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.{<span class="hljs-type">Applicative</span>, <span class="hljs-type">Monoid</span>}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foldable</span>[<span class="hljs-type">F</span>[_]] </span>{
  <span class="hljs-comment">// Given a collection of data F[A], and a function mapping each A to a B where B has a Monoid instance,</span>
  <span class="hljs-comment">// reduce the collection down to a single B value using the monoidal behavior of B</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span> : <span class="hljs-type">Monoid</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span>
}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Traverse</span>[<span class="hljs-type">F</span>[_]] </span>{
  <span class="hljs-comment">// Given a collection of data F[A], for each value apply the function f which returns an effectful</span>
  <span class="hljs-comment">// value. The result of traverse is the composition of all these effectful values.</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">G</span>[_] : <span class="hljs-type">Applicative</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">G</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">G</span>[<span class="hljs-type">F</span>[<span class="hljs-type">B</span>]]
}
</code></pre>
<p>These two type classes seem unrelated - one reduces a collection down to a single value, the other traverses
a collection with an effectful function, collecting results. It may be surprising to see that in fact <code>Traverse</code>
subsumes <code>Foldable</code>.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Traverse</span>[<span class="hljs-type">F</span>[_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">Foldable</span>[<span class="hljs-type">F</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">G</span>[_] : <span class="hljs-type">Applicative</span>, <span class="hljs-type">A</span>, <span class="hljs-type">X</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">G</span>[<span class="hljs-type">X</span>]): <span class="hljs-type">G</span>[<span class="hljs-type">F</span>[<span class="hljs-type">X</span>]]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span> : <span class="hljs-type">Monoid</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span>
}
</code></pre>
<p>To start, we observe that if we are to implement <code>foldMap</code> in terms of <code>traverse</code>, we will want a <code>B</code> out
at some point. However, <code>traverse</code> returns a <code>G[F[X]]</code>. It would seem there is no way to unify these two.
However, if we imagine <code>G[_]</code> to be a sort of type-level constant function, where the fact that it&apos;s taking a
<code>F[X]</code> is irrelevant to the true underlying value, we can begin to see how we might be able to pull this off.</p>
<p><code>traverse</code> however wants <code>G[_]</code> to have an <code>Applicative</code> instance, so let&apos;s define one for <code>Const</code>. Since
<code>F[X]</code> is the value we want to ignore, we treat it as the second type parameter and hence, leave it as the free
one.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Const</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constApplicative</span></span>[<span class="hljs-type">Z</span>]: <span class="hljs-type">Applicative</span>[<span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, ?]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Applicative</span>[<span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, ?]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">A</span>] = ???

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>])(fa: <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">B</span>] = ???
  }
</code></pre>
<p>Recall that <code>Const[Z, A]</code> means we have a <code>Z</code> value in hand, and don&apos;t really care about the <code>A</code> type parameter.
Therefore we can more or less treat the type <code>Const[Z, A]</code> as just <code>Z</code>.</p>
<p>In functions <code>pure</code> and <code>ap</code> we have a problem. In <code>pure</code>, we have an <code>A</code> value, but want to return a <code>Z</code> value. We have
no function <code>A =&gt; Z</code>, so our only option is to completely ignore the <code>A</code> value. But we still don&apos;t have a <code>Z</code>! Let&apos;s
put that aside for now, but still keep it in the back of our minds.</p>
<p>In <code>ap</code> we have two <code>Z</code> values, and want to return a <code>Z</code> value. We could certainly return one or the other, but we
should try to do something more useful. This suggests composition of <code>Z</code>s, which we don&apos;t know how to do.</p>
<p>So now we need a constant <code>Z</code> value, and a binary function that takes two <code>Z</code>s and produces a <code>Z</code>. Sound familiar?
We want <code>Z</code> to have a <code>Monoid</code> instance!</p>
<pre><code class="lang-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constApplicative</span></span>[<span class="hljs-type">Z</span> : <span class="hljs-type">Monoid</span>]: <span class="hljs-type">Applicative</span>[<span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, ?]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Applicative</span>[<span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, ?]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Const</span>(<span class="hljs-type">Monoid</span>[<span class="hljs-type">Z</span>].empty)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>])(fa: <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">Const</span>[<span class="hljs-type">Z</span>, <span class="hljs-type">B</span>] =
      <span class="hljs-type">Const</span>(<span class="hljs-type">Monoid</span>[<span class="hljs-type">Z</span>].combine(fa.getConst, f.getConst))
  }
</code></pre>
<p>We have our <code>Applicative</code>!</p>
<p>Going back to <code>Traverse</code>, we fill in the first parameter of <code>traverse</code> with <code>fa</code> since that&apos;s
the only value that fits.</p>
<p>Now we need a <code>A =&gt; G[B]</code>. We have an <code>A =&gt; B</code>, and we&apos;ve decided to use <code>Const</code> for our <code>G[_]</code>. We need to
fix the first parameter of <code>Const</code> since <code>Const</code> takes two type parameters and <code>traverse</code> wants a type constructor
which only takes one. The first type parameter which will be the type of the actual values we store, and therefore will
be the type of the value we get out at the end, so we leave the second one free, similar to the <code>Applicative</code> instance.
We don&apos;t care about the second type parameter and there are no restrictions on it, so we can just use <code>Nothing</code>,
the type that has no values.</p>
<p>So to summarize, what we want is a function <code>A =&gt; Const[B, Nothing]</code>, and we have a function <code>A =&gt; B</code>. Recall
that <code>Const[B, Z]</code> (for any <code>Z</code>) is the moral equivalent of just <code>B</code>, so <code>A =&gt; Const[B, Nothing]</code> is equivalent
to <code>A =&gt; B</code>, which is exactly what we have, we just need to wrap it.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Traverse</span>[<span class="hljs-type">F</span>[_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">Foldable</span>[<span class="hljs-type">F</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">traverse</span></span>[<span class="hljs-type">G</span>[_] : <span class="hljs-type">Applicative</span>, <span class="hljs-type">A</span>, <span class="hljs-type">X</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">G</span>[<span class="hljs-type">X</span>]): <span class="hljs-type">G</span>[<span class="hljs-type">F</span>[<span class="hljs-type">X</span>]]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span> : <span class="hljs-type">Monoid</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">B</span> = {
    <span class="hljs-keyword">val</span> const: <span class="hljs-type">Const</span>[<span class="hljs-type">B</span>, <span class="hljs-type">F</span>[<span class="hljs-type">Nothing</span>]] = traverse[<span class="hljs-type">Const</span>[<span class="hljs-type">B</span>, ?], <span class="hljs-type">A</span>, <span class="hljs-type">Nothing</span>](fa)(a =&gt; <span class="hljs-type">Const</span>(f(a)))
    const.getConst
  }
}
</code></pre>
<p>Hurrah!</p>
<p>What&apos;s happening here? We can see <code>traverse</code> is a function that goes over a collection, applying an
effectful function to each value, and combining all of these effectful values. In our case, the effect
is mapping each value to a value of type <code>B</code>, where we know how to combine <code>B</code>s via its <code>Monoid</code> instance.
The <code>Monoid</code> instance is exactly what is used when <code>traverse</code> goes to collect the effectful values together.
Should the <code>F[A]</code> be &quot;empty&quot;, it can use <code>Monoid#empty</code> as a value to return back.</p>
<p>Pretty nifty. <code>traverse</code>-ing over a collection with an effectful function is more general than traversing
over a collection to reduce it down to a single value.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="freeapplicative.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Freeapplicative">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"layout":"default","title":"Const","section":"data","source":"core/src/main/scala/cats/data/Const.scala","scaladoc":"#cats.data.Const","level":"1.3.1","depth":2,"next":{"title":"Freeapplicative","level":"1.3.2","depth":2,"path":"freeapplicative.md","ref":"freeapplicative.md","articles":[]},"previous":{"title":"Data Types","level":"1.3","depth":1,"ref":"","articles":[{"title":"Const","level":"1.3.1","depth":2,"path":"const.md","ref":"const.md","articles":[]},{"title":"Freeapplicative","level":"1.3.2","depth":2,"path":"freeapplicative.md","ref":"freeapplicative.md","articles":[]},{"title":"Freemonad","level":"1.3.3","depth":2,"path":"freemonad.md","ref":"freemonad.md","articles":[]},{"title":"Kleisli","level":"1.3.4","depth":2,"path":"kleisli.md","ref":"kleisli.md","articles":[]},{"title":"Oneand","level":"1.3.5","depth":2,"path":"oneand.md","ref":"oneand.md","articles":[]},{"title":"Optiont","level":"1.3.6","depth":2,"path":"optiont.md","ref":"optiont.md","articles":[]},{"title":"State","level":"1.3.7","depth":2,"path":"state.md","ref":"state.md","articles":[]},{"title":"Validated","level":"1.3.8","depth":2,"path":"validated.md","ref":"validated.md","articles":[]},{"title":"Xor","level":"1.3.9","depth":2,"path":"xor.md","ref":"xor.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"const.md","mtime":"2016-06-18T19:51:36.364Z","type":"markdown"},"gitbook":{"version":"3.0.3","time":"2016-06-18T20:02:33.141Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/buttons.js"></script>
        
    

    </body>
</html>

