
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>Xor Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.0.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="CONTRIBUTING.html" />
    
    
    <link rel="prev" href="validated.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="typeclasses.html">
            
                <a href="typeclasses.html">
            
                    
                    Typeclasses
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="applicative.html">
            
                <a href="applicative.html">
            
                    
                    Applicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="apply.html">
            
                <a href="apply.html">
            
                    
                    Apply
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="contravariant.html">
            
                <a href="contravariant.html">
            
                    
                    Contravariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    Faq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="foldable.html">
            
                <a href="foldable.html">
            
                    
                    Foldable
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="functor.html">
            
                <a href="functor.html">
            
                    
                    Functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="id.html">
            
                <a href="id.html">
            
                    
                    Id
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="invariant.html">
            
                <a href="invariant.html">
            
                    
                    Invariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="monad.html">
            
                <a href="monad.html">
            
                    
                    Monad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="monadcombine.md">
            
                <a href="monadcombine.md">
            
                    
                    Monadcombine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="monadfilter.md">
            
                <a href="monadfilter.md">
            
                    
                    Monadfilter
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="monoid.html">
            
                <a href="monoid.html">
            
                    
                    Monoid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="monoidk.md">
            
                <a href="monoidk.md">
            
                    
                    Monoidk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="semigroup.html">
            
                <a href="semigroup.html">
            
                    
                    Semigroup
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="semigroupk.html">
            
                <a href="semigroupk.html">
            
                    
                    Semigroupk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="show.md">
            
                <a href="show.md">
            
                    
                    Show
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="traverse.html">
            
                <a href="traverse.html">
            
                    
                    Traverse
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Data Types
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="const.html">
            
                <a href="const.html">
            
                    
                    Const
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="freeapplicative.html">
            
                <a href="freeapplicative.html">
            
                    
                    Freeapplicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="freemonad.html">
            
                <a href="freemonad.html">
            
                    
                    Freemonad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="kleisli.html">
            
                <a href="kleisli.html">
            
                    
                    Kleisli
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="oneand.html">
            
                <a href="oneand.html">
            
                    
                    Oneand
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="optiont.html">
            
                <a href="optiont.html">
            
                    
                    Optiont
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="state.html">
            
                <a href="state.html">
            
                    
                    State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="validated.html">
            
                <a href="validated.html">
            
                    
                    Validated
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.9" data-path="xor.html">
            
                <a href="xor.html">
            
                    
                    Xor
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="CONTRIBUTING.html">
            
                <a href="CONTRIBUTING.html">
            
                    
                    Contributing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="PROCESS.html">
            
                <a href="PROCESS.html">
            
                    
                    Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="AUTHORS.html">
            
                <a href="AUTHORS.html">
            
                    
                    Authors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="CHANGES.html">
            
                <a href="CHANGES.html">
            
                    
                    Changes
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Xor</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="xor">Xor</h1>
<p>In day-to-day programming, it is fairly common to find ourselves writing functions that
can fail. For instance, querying a service may result in a connection issue, or some
unexpected JSON response.</p>
<p>To communicate these errors it has become common practice to throw exceptions. However,
exceptions are not tracked in any way, shape, or form by the Scala compiler. To see
what kind of exceptions (if any) a function may throw, we have to dig through the source code.
Then to handle these exceptions, we have to make sure we catch them at the call site.
This all becomes even more unwieldy when we try to compose exception-throwing procedures.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> throwsSomeStuff: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Double</span> = ???

<span class="hljs-keyword">val</span> throwsOtherThings: <span class="hljs-type">Double</span> =&gt; <span class="hljs-type">String</span> = ???

<span class="hljs-keyword">val</span> moreThrowing: <span class="hljs-type">String</span> =&gt; <span class="hljs-type">List</span>[<span class="hljs-type">Char</span>] = ???

<span class="hljs-keyword">val</span> magic = throwsSomeStuff.andThen(throwsOtherThings).andThen(moreThrowing)
</code></pre>
<p>Assume we happily throw exceptions in our code. Looking at the types, any of those functions
can throw any number of exceptions, we don&apos;t know. When we compose, exceptions from any of
the constituent functions can be thrown. Moreover, they may throw the same kind of exception
(e.g. <code>IllegalArgumentException</code>) and thus it gets tricky tracking exactly where that
exception came from.</p>
<p>How then do we communicate an error? By making it explicit in the data type we return.</p>
<h2 id="xor">Xor</h2>
<h3 id="xor-vs-validated"><code>Xor</code> vs <code>Validated</code></h3>
<p>In general, <code>Validated</code> is used to accumulate errors, while <code>Xor</code> is used to short-circuit a computation upon the first error. For more information, see the <code>Validated</code> vs <code>Xor</code> section of the <a href="tut/validated.html"><code>Validated</code> documentation</a>.</p>
<h3 id="why-not-either">Why not <code>Either</code></h3>
<p><code>Xor</code> is very similar to <code>scala.util.Either</code> - in fact, they are <em>isomorphic</em> (that is,
any <code>Either</code> value can be rewritten as an <code>Xor</code> value, and vice versa).</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Xor</span>[+<span class="hljs-type">A</span>, +<span class="hljs-type">B</span>]</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Xor</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Left</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">a: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Xor</span>[<span class="hljs-type">A</span>, <span class="hljs-type">Nothing</span>]</span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Right</span>[+<span class="hljs-type">B</span>](<span class="hljs-params">b: <span class="hljs-type">B</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Xor</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">B</span>]</span>
}
</code></pre>
<p>Just like <code>Either</code>, it has two type parameters. Instances of <code>Xor</code> either hold a value
of one type parameter, or the other. Why then does it exist at all?</p>
<p>Taking a look at <code>Either</code>, we notice it lacks <code>flatMap</code> and <code>map</code> methods. In order to map
over an <code>Either[A, B]</code> value, we have to state which side we want to map over. For example,
if we want to map <code>Either[A, B]</code> to <code>Either[A, C]</code> we would need to map over the right side.
This can be accomplished by using the <code>Either#right</code> method, which returns a <code>RightProjection</code>
instance. <code>RightProjection</code> does have <code>flatMap</code> and <code>map</code> on it, which acts on the right side
and ignores the left - this property is referred to as &quot;right-bias.&quot;</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> e1: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Right</span>(<span class="hljs-number">5</span>)
<span class="hljs-comment">// e1: Either[String,Int] = Right(5)</span>

e1.right.map(_ + <span class="hljs-number">1</span>)
<span class="hljs-comment">// res0: Product with Serializable with scala.util.Either[String,Int] = Right(6)</span>

<span class="hljs-keyword">val</span> e2: <span class="hljs-type">Either</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Left</span>(<span class="hljs-string">&quot;hello&quot;</span>)
<span class="hljs-comment">// e2: Either[String,Int] = Left(hello)</span>

e2.right.map(_ + <span class="hljs-number">1</span>)
<span class="hljs-comment">// res1: Product with Serializable with scala.util.Either[String,Int] = Left(hello)</span>
</code></pre>
<p>Note the return types are themselves back to <code>Either</code>, so if we want to make more calls to
<code>flatMap</code> or <code>map</code> then we again must call <code>right</code> or <code>left</code>.</p>
<p>More often than not we want to just bias towards one side and call it a day - by convention,
the right side is most often chosen. This is the primary difference between <code>Xor</code> and <code>Either</code> -
<code>Xor</code> is right-biased. <code>Xor</code> also has some more convenient methods on it, but the most
crucial one is the right-biased being built-in.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Xor</span>
<span class="hljs-comment">// import cats.data.Xor</span>

<span class="hljs-keyword">val</span> xor1: <span class="hljs-type">Xor</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Xor</span>.right(<span class="hljs-number">5</span>)
<span class="hljs-comment">// xor1: cats.data.Xor[String,Int] = Right(5)</span>

xor1.map(_ + <span class="hljs-number">1</span>)
<span class="hljs-comment">// res2: cats.data.Xor[String,Int] = Right(6)</span>

<span class="hljs-keyword">val</span> xor2: <span class="hljs-type">Xor</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-type">Xor</span>.left(<span class="hljs-string">&quot;hello&quot;</span>)
<span class="hljs-comment">// xor2: cats.data.Xor[String,Int] = Left(hello)</span>

xor2.map(_ + <span class="hljs-number">1</span>)
<span class="hljs-comment">// res3: cats.data.Xor[String,Int] = Left(hello)</span>
</code></pre>
<p>Because <code>Xor</code> is right-biased, it is possible to define a <code>Monad</code> instance for it. You
could also define one for <code>Either</code> but due to how it&apos;s encoded it may seem strange to fix a
bias direction despite it intending to be flexible in that regard. The <code>Monad</code> instance for
<code>Xor</code> is consistent with the behavior of the data type itself, whereas the one for <code>Either</code>
would only introduce bias when <code>Either</code> is used in a generic context (a function abstracted
over <code>M[_] : Monad</code>).</p>
<p>Since we only ever want the computation to continue in the case of <code>Xor.Right</code> (as captured
by the right-bias nature), we fix the left type parameter and leave the right one free.</p>
<p><em>Note</em>: the example below assumes usage of the <a href="https://github.com/non/kind-projector" _target="blank">kind-projector compiler plugin</a> and will not compile if it is not being used in a project.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Monad</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xorMonad</span></span>[<span class="hljs-type">Err</span>]: <span class="hljs-type">Monad</span>[<span class="hljs-type">Xor</span>[<span class="hljs-type">Err</span>, ?]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Monad</span>[<span class="hljs-type">Xor</span>[<span class="hljs-type">Err</span>, ?]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">Xor</span>[<span class="hljs-type">Err</span>, <span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Xor</span>[<span class="hljs-type">Err</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Xor</span>[<span class="hljs-type">Err</span>, <span class="hljs-type">B</span>] =
      fa.flatMap(f)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](x: <span class="hljs-type">A</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">Err</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Xor</span>.right(x)
  }
</code></pre>
<h3 id="example-usage-round-1">Example usage: Round 1</h3>
<p>As a running example, we will have a series of functions that will parse a string into an integer,
take the reciprocal, and then turn the reciprocal into a string.</p>
<p>In exception-throwing code, we would have something like this:</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ExceptionStyle</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Int</span> =
    <span class="hljs-keyword">if</span> (s.matches(<span class="hljs-string">&quot;-?[0-9]+&quot;</span>)) s.toInt
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NumberFormatException</span>(<span class="hljs-string">s&quot;<span class="hljs-subst">${s}</span> is not a valid integer.&quot;</span>)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reciprocal</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">Double</span> =
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot take reciprocal of 0.&quot;</span>)
    <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span> / i

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stringify</span></span>(d: <span class="hljs-type">Double</span>): <span class="hljs-type">String</span> = d.toString
}
</code></pre>
<p>Instead, let&apos;s make the fact that some of our functions can fail explicit in the return type.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">XorStyle</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">NumberFormatException</span>, <span class="hljs-type">Int</span>] =
    <span class="hljs-keyword">if</span> (s.matches(<span class="hljs-string">&quot;-?[0-9]+&quot;</span>)) <span class="hljs-type">Xor</span>.right(s.toInt)
    <span class="hljs-keyword">else</span> <span class="hljs-type">Xor</span>.left(<span class="hljs-keyword">new</span> <span class="hljs-type">NumberFormatException</span>(<span class="hljs-string">s&quot;<span class="hljs-subst">${s}</span> is not a valid integer.&quot;</span>))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reciprocal</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">IllegalArgumentException</span>, <span class="hljs-type">Double</span>] =
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-type">Xor</span>.left(<span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Cannot take reciprocal of 0.&quot;</span>))
    <span class="hljs-keyword">else</span> <span class="hljs-type">Xor</span>.right(<span class="hljs-number">1.0</span> / i)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stringify</span></span>(d: <span class="hljs-type">Double</span>): <span class="hljs-type">String</span> = d.toString
}
</code></pre>
<p>Now, using combinators like <code>flatMap</code> and <code>map</code>, we can compose our functions together.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">XorStyle</span>._

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">magic</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">Exception</span>, <span class="hljs-type">String</span>] =
  parse(s).flatMap(reciprocal).map(stringify)
</code></pre>
<p>With the composite function that we actually care about, we can pass in strings and then pattern
match on the exception. Because <code>Xor</code> is a sealed type (often referred to as an algebraic data type,
or ADT), the compiler will complain if we do not check both the <code>Left</code> and <code>Right</code> case.</p>
<pre><code class="lang-scala">magic(<span class="hljs-string">&quot;123&quot;</span>) <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(_: <span class="hljs-type">NumberFormatException</span>) =&gt; println(<span class="hljs-string">&quot;not a number!&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(_: <span class="hljs-type">IllegalArgumentException</span>) =&gt; println(<span class="hljs-string">&quot;can&apos;t take reciprocal of 0!&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(_) =&gt; println(<span class="hljs-string">&quot;got unknown exception&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Right</span>(s) =&gt; println(<span class="hljs-string">s&quot;Got reciprocal: <span class="hljs-subst">${s}</span>&quot;</span>)
}
<span class="hljs-comment">// Got reciprocal: 0.008130081300813009</span>
</code></pre>
<p>Not bad - if we leave out any of those clauses the compiler will yell at us, as it should. However,
note the <code>Xor.Left(_)</code> clause - the compiler will complain if we leave that out because it knows
that given the type <code>Xor[Exception, String]</code>, there can be inhabitants of <code>Xor.Left</code> that are not
<code>NumberFormatException</code> or <code>IllegalArgumentException</code>. However, we &quot;know&quot; by inspection of the source
that those will be the only exceptions thrown, so it seems strange to have to account for other exceptions.
This implies that there is still room to improve.</p>
<h3 id="example-usage-round-2">Example usage: Round 2</h3>
<p>Instead of using exceptions as our error value, let&apos;s instead enumerate explicitly the things that
can go wrong in our program.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">XorStyle</span> </span>{
  <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span></span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotANumber</span>(<span class="hljs-params">string: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span></span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoZeroReciprocal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span></span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">Error</span>, <span class="hljs-type">Int</span>] =
    <span class="hljs-keyword">if</span> (s.matches(<span class="hljs-string">&quot;-?[0-9]+&quot;</span>)) <span class="hljs-type">Xor</span>.right(s.toInt)
    <span class="hljs-keyword">else</span> <span class="hljs-type">Xor</span>.left(<span class="hljs-type">NotANumber</span>(s))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reciprocal</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">Error</span>, <span class="hljs-type">Double</span>] =
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-type">Xor</span>.left(<span class="hljs-type">NoZeroReciprocal</span>)
    <span class="hljs-keyword">else</span> <span class="hljs-type">Xor</span>.right(<span class="hljs-number">1.0</span> / i)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stringify</span></span>(d: <span class="hljs-type">Double</span>): <span class="hljs-type">String</span> = d.toString

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">magic</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">Error</span>, <span class="hljs-type">String</span>] =
    parse(s).flatMap(reciprocal).map(stringify)
}
</code></pre>
<p>For our little module, we enumerate any and all errors that can occur. Then, instead of using
exception classes as error values, we use one of the enumerated cases. Now when we pattern
match, we get much nicer matching. Moreover, since <code>Error</code> is <code>sealed</code>, no outside code can
add additional subtypes which we might fail to handle.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">XorStyle</span>._
<span class="hljs-comment">// import XorStyle._</span>

magic(<span class="hljs-string">&quot;123&quot;</span>) <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(<span class="hljs-type">NotANumber</span>(_)) =&gt; println(<span class="hljs-string">&quot;not a number!&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(<span class="hljs-type">NoZeroReciprocal</span>) =&gt; println(<span class="hljs-string">&quot;can&apos;t take reciprocal of 0!&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Right</span>(s) =&gt; println(<span class="hljs-string">s&quot;Got reciprocal: <span class="hljs-subst">${s}</span>&quot;</span>)
}
<span class="hljs-comment">// Got reciprocal: 0.008130081300813009</span>
</code></pre>
<h2 id="xor-in-the-small-xor-in-the-large">Xor in the small, Xor in the large</h2>
<p>Once you start using <code>Xor</code> for all your error-handling, you may quickly run into an issue where
you need to call into two separate modules which give back separate kinds of errors.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseError</span></span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DatabaseValue</span></span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Database</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">databaseThings</span></span>(): <span class="hljs-type">Xor</span>[<span class="hljs-type">DatabaseError</span>, <span class="hljs-type">DatabaseValue</span>] = ???
}

<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceError</span></span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ServiceValue</span></span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Service</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serviceThings</span></span>(v: <span class="hljs-type">DatabaseValue</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">ServiceError</span>, <span class="hljs-type">ServiceValue</span>] = ???
}
</code></pre>
<p>Let&apos;s say we have an application that wants to do database things, and then take database
values and do service things. Glancing at the types, it looks like <code>flatMap</code> will do it.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doApp</span> </span>= <span class="hljs-type">Database</span>.databaseThings().flatMap(<span class="hljs-type">Service</span>.serviceThings)
</code></pre>
<p>This doesn&apos;t work! Well, it does, but it gives us <code>Xor[Object, ServiceValue]</code> which isn&apos;t
particularly useful for us. Now if we inspect the <code>Left</code>s, we have no clue what it could be.
The reason this occurs is because the first type parameter in the two <code>Xor</code>s are different -
<code>databaseThings()</code> can give us a <code>DatabaseError</code> whereas <code>serviceThings()</code> can give us a
<code>ServiceError</code>: two completely unrelated types. Recall that the type parameters of <code>Xor</code>
are covariant, so when it sees an <code>Xor[E1, A1]</code> and an <code>Xor[E2, A2]</code>, it will happily try
to unify the <code>E1</code> and <code>E2</code> in a <code>flatMap</code> call - in our case, the closest common supertype is
<code>Object</code>, leaving us with practically no type information to use in our pattern match.</p>
<h3 id="solution-1-application-wide-errors">Solution 1: Application-wide errors</h3>
<p>So clearly in order for us to easily compose <code>Xor</code> values, the left type parameter must be the same.
We may then be tempted to make our entire application share an error data type.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppError</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DatabaseError1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppError</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DatabaseError2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppError</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ServiceError1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppError</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ServiceError2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppError</span></span>

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DatabaseValue</span></span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Database</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">databaseThings</span></span>(): <span class="hljs-type">Xor</span>[<span class="hljs-type">AppError</span>, <span class="hljs-type">DatabaseValue</span>] = ???
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Service</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serviceThings</span></span>(v: <span class="hljs-type">DatabaseValue</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">AppError</span>, <span class="hljs-type">ServiceValue</span>] = ???
}

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doApp</span> </span>= <span class="hljs-type">Database</span>.databaseThings().flatMap(<span class="hljs-type">Service</span>.serviceThings)
</code></pre>
<p>This certainly works, or at least it compiles. But consider the case where another module wants to just use
<code>Database</code>, and gets an <code>Xor[AppError, DatabaseValue]</code> back. Should it want to inspect the errors, it
must inspect <strong>all</strong> the <code>AppError</code> cases, even though it was only intended for <code>Database</code> to use
<code>DatabaseError1</code> or <code>DatabaseError2</code>.</p>
<h3 id="solution-2-adts-all-the-way-down">Solution 2: ADTs all the way down</h3>
<p>Instead of lumping all our errors into one big ADT, we can instead keep them local to each module, and have
an application-wide error ADT that wraps each error ADT we need.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseError</span></span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DatabaseValue</span></span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Database</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">databaseThings</span></span>(): <span class="hljs-type">Xor</span>[<span class="hljs-type">DatabaseError</span>, <span class="hljs-type">DatabaseValue</span>] = ???
}

<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceError</span></span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">ServiceValue</span></span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Service</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serviceThings</span></span>(v: <span class="hljs-type">DatabaseValue</span>): <span class="hljs-type">Xor</span>[<span class="hljs-type">ServiceError</span>, <span class="hljs-type">ServiceValue</span>] = ???
}

<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppError</span></span>
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">AppError</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Database</span>(<span class="hljs-params">error: <span class="hljs-type">DatabaseError</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">AppError</span></span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span>(<span class="hljs-params">error: <span class="hljs-type">ServiceError</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">AppError</span></span>
}
</code></pre>
<p>Now in our outer application, we can wrap/lift each module-specific error into <code>AppError</code> and then
call our combinators as usual. <code>Xor</code> provides a convenient method to assist with this, called <code>Xor.leftMap</code> -
it can be thought of as the same as <code>map</code>, but for the <code>Left</code> side.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doApp</span></span>: <span class="hljs-type">Xor</span>[<span class="hljs-type">AppError</span>, <span class="hljs-type">ServiceValue</span>] =
  <span class="hljs-type">Database</span>.databaseThings().leftMap(<span class="hljs-type">AppError</span>.<span class="hljs-type">Database</span>).
  flatMap(dv =&gt; <span class="hljs-type">Service</span>.serviceThings(dv).leftMap(<span class="hljs-type">AppError</span>.<span class="hljs-type">Service</span>))
</code></pre>
<p>Hurrah! Each module only cares about its own errors as it should be, and more composite modules have their
own error ADT that encapsulates each constituent module&apos;s error ADT. Doing this also allows us to take action
on entire classes of errors instead of having to pattern match on each individual one.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">awesome</span> </span>=
  doApp <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(<span class="hljs-type">AppError</span>.<span class="hljs-type">Database</span>(_)) =&gt; <span class="hljs-string">&quot;something in the database went wrong&quot;</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Left</span>(<span class="hljs-type">AppError</span>.<span class="hljs-type">Service</span>(_))  =&gt; <span class="hljs-string">&quot;something in the service went wrong&quot;</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Xor</span>.<span class="hljs-type">Right</span>(_)                   =&gt; <span class="hljs-string">&quot;everything is alright!&quot;</span>
  }
</code></pre>
<h2 id="working-with-exception-y-code">Working with exception-y code</h2>
<p>There will inevitably come a time when your nice <code>Xor</code> code will have to interact with exception-throwing
code. Handling such situations is easy enough.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> xor: <span class="hljs-type">Xor</span>[<span class="hljs-type">NumberFormatException</span>, <span class="hljs-type">Int</span>] =
  <span class="hljs-keyword">try</span> {
    <span class="hljs-type">Xor</span>.right(<span class="hljs-string">&quot;abc&quot;</span>.toInt)
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">case</span> nfe: <span class="hljs-type">NumberFormatException</span> =&gt; <span class="hljs-type">Xor</span>.left(nfe)
  }
<span class="hljs-comment">// xor: cats.data.Xor[NumberFormatException,Int] = Left(java.lang.NumberFormatException: For input string: &quot;abc&quot;)</span>
</code></pre>
<p>However, this can get tedious quickly. <code>Xor</code> provides a <code>catchOnly</code> method on its companion object
that allows you to pass it a function, along with the type of exception you want to catch, and does the
above for you.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> xor: <span class="hljs-type">Xor</span>[<span class="hljs-type">NumberFormatException</span>, <span class="hljs-type">Int</span>] =
  <span class="hljs-type">Xor</span>.catchOnly[<span class="hljs-type">NumberFormatException</span>](<span class="hljs-string">&quot;abc&quot;</span>.toInt)
<span class="hljs-comment">// xor: cats.data.Xor[NumberFormatException,Int] = Left(java.lang.NumberFormatException: For input string: &quot;abc&quot;)</span>
</code></pre>
<p>If you want to catch all (non-fatal) throwables, you can use <code>catchNonFatal</code>.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> xor: <span class="hljs-type">Xor</span>[<span class="hljs-type">Throwable</span>, <span class="hljs-type">Int</span>] =
  <span class="hljs-type">Xor</span>.catchNonFatal(<span class="hljs-string">&quot;abc&quot;</span>.toInt)
<span class="hljs-comment">// xor: cats.data.Xor[Throwable,Int] = Left(java.lang.NumberFormatException: For input string: &quot;abc&quot;)</span>
</code></pre>
<h2 id="additional-syntax">Additional syntax</h2>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.implicits._
<span class="hljs-comment">// import cats.implicits._</span>

<span class="hljs-keyword">val</span> xor3: <span class="hljs-type">Xor</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-number">7.</span>right[<span class="hljs-type">String</span>]
<span class="hljs-comment">// xor3: cats.data.Xor[String,Int] = Right(7)</span>

<span class="hljs-keyword">val</span> xor4: <span class="hljs-type">Xor</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>] = <span class="hljs-string">&quot;hello &#x1F408;s&quot;</span>.left[<span class="hljs-type">Int</span>]
<span class="hljs-comment">// xor4: cats.data.Xor[String,Int] = Left(hello &#x1F408;s)</span>
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="validated.html" class="navigation navigation-prev " aria-label="Previous page: Validated">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="CONTRIBUTING.html" class="navigation navigation-next " aria-label="Next page: Contributing">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"layout":"default","title":"Xor","section":"data","source":"core/src/main/scala/cats/data/Xor.scala","scaladoc":"#cats.data.Xor","level":"1.3.9","depth":2,"next":{"title":"Contributing","level":"1.4","depth":1,"path":"CONTRIBUTING.md","ref":"CONTRIBUTING.md","articles":[]},"previous":{"title":"Validated","level":"1.3.8","depth":2,"path":"validated.md","ref":"validated.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"xor.md","mtime":"2016-06-18T19:52:21.400Z","type":"markdown"},"gitbook":{"version":"3.0.3","time":"2016-06-18T20:02:33.141Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/buttons.js"></script>
        
    

    </body>
</html>

