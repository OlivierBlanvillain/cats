
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>Freemonad Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.0.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="kleisli.html" />
    
    
    <link rel="prev" href="freeapplicative.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="typeclasses.html">
            
                <a href="typeclasses.html">
            
                    
                    Typeclasses
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="applicative.html">
            
                <a href="applicative.html">
            
                    
                    Applicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="apply.html">
            
                <a href="apply.html">
            
                    
                    Apply
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="contravariant.html">
            
                <a href="contravariant.html">
            
                    
                    Contravariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    Faq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="foldable.html">
            
                <a href="foldable.html">
            
                    
                    Foldable
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="functor.html">
            
                <a href="functor.html">
            
                    
                    Functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="id.html">
            
                <a href="id.html">
            
                    
                    Id
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="invariant.html">
            
                <a href="invariant.html">
            
                    
                    Invariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="monad.html">
            
                <a href="monad.html">
            
                    
                    Monad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="monadcombine.md">
            
                <a href="monadcombine.md">
            
                    
                    Monadcombine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="monadfilter.md">
            
                <a href="monadfilter.md">
            
                    
                    Monadfilter
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="monoid.html">
            
                <a href="monoid.html">
            
                    
                    Monoid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="monoidk.md">
            
                <a href="monoidk.md">
            
                    
                    Monoidk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="semigroup.html">
            
                <a href="semigroup.html">
            
                    
                    Semigroup
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="semigroupk.html">
            
                <a href="semigroupk.html">
            
                    
                    Semigroupk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="show.md">
            
                <a href="show.md">
            
                    
                    Show
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="traverse.html">
            
                <a href="traverse.html">
            
                    
                    Traverse
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Data Types
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="const.html">
            
                <a href="const.html">
            
                    
                    Const
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="freeapplicative.html">
            
                <a href="freeapplicative.html">
            
                    
                    Freeapplicative
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.3" data-path="freemonad.html">
            
                <a href="freemonad.html">
            
                    
                    Freemonad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="kleisli.html">
            
                <a href="kleisli.html">
            
                    
                    Kleisli
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="oneand.html">
            
                <a href="oneand.html">
            
                    
                    Oneand
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="optiont.html">
            
                <a href="optiont.html">
            
                    
                    Optiont
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="state.html">
            
                <a href="state.html">
            
                    
                    State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="validated.html">
            
                <a href="validated.html">
            
                    
                    Validated
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="xor.html">
            
                <a href="xor.html">
            
                    
                    Xor
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="CONTRIBUTING.html">
            
                <a href="CONTRIBUTING.html">
            
                    
                    Contributing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="PROCESS.html">
            
                <a href="PROCESS.html">
            
                    
                    Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="AUTHORS.html">
            
                <a href="AUTHORS.html">
            
                    
                    Authors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="CHANGES.html">
            
                <a href="CHANGES.html">
            
                    
                    Changes
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Freemonad</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="free-monad">Free Monad</h1>
<h2 id="what-is-it">What is it?</h2>
<p>A <em>free monad</em> is a construction which allows you to build a <em>monad</em>
from any <em>Functor</em>. Like other <em>monads</em>, it is a pure way to represent
and manipulate computations.</p>
<p>In particular, <em>free monads</em> provide a practical way to:</p>
<ul>
<li>represent stateful computations as data, and run them</li>
<li>run recursive computations in a stack-safe way</li>
<li>build an embedded DSL (domain-specific language)</li>
<li>retarget a computation to another interpreter using natural transformations</li>
</ul>
<blockquote>
<p>(In cats, the type representing a <em>free monad</em> is abbreviated as <code>Free[_]</code>.)</p>
</blockquote>
<h2 id="using-free-monads">Using Free Monads</h2>
<p>If you&apos;d like to use cats&apos; free monad, you&apos;ll need to add a library dependency
for the <code>cats-free</code> module.</p>
<p>A good way to get a sense for how <em>free monads</em> work is to see them in
action. The next section uses <code>Free[_]</code> to create an embedded DSL
(Domain Specific Language).</p>
<p>If you&apos;re interested in the theory behind <em>free monads</em>, the
<a href="#what-is-free-in-theory">What is Free in theory?</a> section discusses free monads
in terms of category theory.</p>
<h3 id="study-your-topic">Study your topic</h3>
<p>Let&apos;s imagine that we want to create a DSL for a key-value store. We
want to be able to do three things with keys:</p>
<ul>
<li><em>put</em> a <code>value</code> into the store, associated with its <code>key</code>.</li>
<li><em>get</em> a <code>value</code> from the store given its <code>key</code>.</li>
<li><em>delete</em> a <code>value</code> from the store given its <code>key</code>.</li>
</ul>
<p>The idea is to write a sequence of these operations in the embedded
DSL as a &quot;program&quot;, compile the &quot;program&quot;, and finally execute the
&quot;program&quot; to interact with the actual key-value store.</p>
<p>For example:</p>
<pre><code class="lang-scala">put(<span class="hljs-string">&quot;toto&quot;</span>, <span class="hljs-number">3</span>)
get(<span class="hljs-string">&quot;toto&quot;</span>) <span class="hljs-comment">// returns 3</span>
delete(<span class="hljs-string">&quot;toto&quot;</span>)
</code></pre>
<p>But we want:</p>
<ul>
<li>the computation to be represented as a pure, immutable value</li>
<li>to separate the creation and execution of the program</li>
<li>to be able to support many different methods of execution</li>
</ul>
<h3 id="study-your-grammar">Study your grammar</h3>
<p>We have 3 commands to interact with our KeyValue store:</p>
<ul>
<li><code>Put</code> a value associated with a key into the store</li>
<li><code>Get</code> a value associated with a key out of the store</li>
<li><code>Delete</code> a value associated with a key from the store</li>
</ul>
<h3 id="create-an-adt-representing-your-grammar">Create an ADT representing your grammar</h3>
<p>ADT stands for <em>Algebraic Data Type</em>. In this context, it refers to a
closed set of types which can be combined to build up complex,
recursive values.</p>
<p>We need to create an ADT to represent our key-value operations:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">KVStoreA</span>[<span class="hljs-type">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Put</span>[<span class="hljs-type">T</span>](<span class="hljs-params">key: <span class="hljs-type">String</span>, value: <span class="hljs-type">T</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">KVStoreA</span>[<span class="hljs-type">Unit</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Get</span>[<span class="hljs-type">T</span>](<span class="hljs-params">key: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">KVStoreA</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">T</span>]]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delete</span>(<span class="hljs-params">key: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">KVStoreA</span>[<span class="hljs-type">Unit</span>]</span>
</code></pre>
<h3 id="free-your-adt">Free your ADT</h3>
<p>There are six basic steps to &quot;freeing&quot; the ADT:</p>
<ol>
<li>Create a type based on <code>Free[_]</code> and <code>KVStoreA[_]</code>.</li>
<li>Create smart constructors for <code>KVStore[_]</code> using <code>liftF</code>.</li>
<li>Build a program out of key-value DSL operations.</li>
<li>Build a compiler for programs of DSL operations.</li>
<li>Execute our compiled program.</li>
</ol>
<h4 id="1-create-a-free-type-based-on-your-adt">1. Create a <code>Free</code> type based on your ADT</h4>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.free.<span class="hljs-type">Free</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">KVStore</span>[<span class="hljs-type">A</span>] </span>= <span class="hljs-type">Free</span>[<span class="hljs-type">KVStoreA</span>, <span class="hljs-type">A</span>]
</code></pre>
<h4 id="2-create-smart-constructors-using-liftf">2. Create smart constructors using <code>liftF</code></h4>
<p>These methods will make working with our DSL a lot nicer, and will
lift <code>KVStoreA[_]</code> values into our <code>KVStore[_]</code> monad (note the
missing &quot;A&quot; in the second type).</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.free.<span class="hljs-type">Free</span>.liftF

<span class="hljs-comment">// Put returns nothing (i.e. Unit).</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span></span>[<span class="hljs-type">T</span>](key: <span class="hljs-type">String</span>, value: <span class="hljs-type">T</span>): <span class="hljs-type">KVStore</span>[<span class="hljs-type">Unit</span>] =
  liftF[<span class="hljs-type">KVStoreA</span>, <span class="hljs-type">Unit</span>](<span class="hljs-type">Put</span>[<span class="hljs-type">T</span>](key, value))

<span class="hljs-comment">// Get returns a T value.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>[<span class="hljs-type">T</span>](key: <span class="hljs-type">String</span>): <span class="hljs-type">KVStore</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">T</span>]] =
  liftF[<span class="hljs-type">KVStoreA</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">T</span>]](<span class="hljs-type">Get</span>[<span class="hljs-type">T</span>](key))

<span class="hljs-comment">// Delete returns nothing (i.e. Unit).</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span></span>(key: <span class="hljs-type">String</span>): <span class="hljs-type">KVStore</span>[<span class="hljs-type">Unit</span>] =
  liftF(<span class="hljs-type">Delete</span>(key))

<span class="hljs-comment">// Update composes get and set, and returns nothing.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>[<span class="hljs-type">T</span>](key: <span class="hljs-type">String</span>, f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">T</span>): <span class="hljs-type">KVStore</span>[<span class="hljs-type">Unit</span>] =
  <span class="hljs-keyword">for</span> {
    vMaybe &lt;- get[<span class="hljs-type">T</span>](key)
    _ &lt;- vMaybe.map(v =&gt; put[<span class="hljs-type">T</span>](key, f(v))).getOrElse(<span class="hljs-type">Free</span>.pure(()))
  } <span class="hljs-keyword">yield</span> ()
</code></pre>
<h4 id="3-build-a-program">3. Build a program</h4>
<p>Now that we can construct <code>KVStore[_]</code> values we can use our DSL to
write &quot;programs&quot; using a <em>for-comprehension</em>:</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">program</span></span>: <span class="hljs-type">KVStore</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]] =
  <span class="hljs-keyword">for</span> {
    _ &lt;- put(<span class="hljs-string">&quot;wild-cats&quot;</span>, <span class="hljs-number">2</span>)
    _ &lt;- update[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;wild-cats&quot;</span>, (_ + <span class="hljs-number">12</span>))
    _ &lt;- put(<span class="hljs-string">&quot;tame-cats&quot;</span>, <span class="hljs-number">5</span>)
    n &lt;- get[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;wild-cats&quot;</span>)
    _ &lt;- delete(<span class="hljs-string">&quot;tame-cats&quot;</span>)
  } <span class="hljs-keyword">yield</span> n
</code></pre>
<p>This looks like a monadic flow. However, it just builds a recursive
data structure representing the sequence of operations.</p>
<h4 id="4-write-a-compiler-for-your-program">4. Write a compiler for your program</h4>
<p>As you may have understood now, <code>Free[_]</code> is used to create an embedded
DSL. By itself, this DSL only represents a sequence of operations
(defined by a recursive data structure); it doesn&apos;t produce anything.</p>
<p><code>Free[_]</code> is a programming language inside your programming language!</p>
<p><strong>So, like any other programming language, we need to compile our
  abstract language into an <em>effective</em> language and then run it.</strong></p>
<p>To do this, we will use a <em>natural transformation</em> between type
containers.  Natural transformations go between types like <code>F[_]</code> and
<code>G[_]</code> (this particular transformation would be written as
<code>FunctionK[F,G]</code> or as done here using the symbolic
alternative as <code>F ~&gt; G</code>).</p>
<p>In our case, we will use a simple mutable map to represent our key
value store:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.arrow.<span class="hljs-type">FunctionK</span>
<span class="hljs-keyword">import</span> cats.{<span class="hljs-type">Id</span>, ~&gt;}
<span class="hljs-keyword">import</span> scala.collection.mutable

<span class="hljs-comment">// the program will crash if a key is not found,</span>
<span class="hljs-comment">// or if a type is incorrectly specified.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">impureCompiler</span></span>: <span class="hljs-type">KVStoreA</span> ~&gt; <span class="hljs-type">Id</span>  =
  <span class="hljs-keyword">new</span> (<span class="hljs-type">KVStoreA</span> ~&gt; <span class="hljs-type">Id</span>) {

    <span class="hljs-comment">// a very simple (and imprecise) key-value store</span>
    <span class="hljs-keyword">val</span> kvs = mutable.<span class="hljs-type">Map</span>.empty[<span class="hljs-type">String</span>, <span class="hljs-type">Any</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">KVStoreA</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Id</span>[<span class="hljs-type">A</span>] =
      fa <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Put</span>(key, value) =&gt;
          println(<span class="hljs-string">s&quot;put(<span class="hljs-subst">$key</span>, <span class="hljs-subst">$value</span>)&quot;</span>)
          kvs(key) = value
          ()
        <span class="hljs-keyword">case</span> <span class="hljs-type">Get</span>(key) =&gt;
          println(<span class="hljs-string">s&quot;get(<span class="hljs-subst">$key</span>)&quot;</span>)
          kvs.get(key).map(_.asInstanceOf[<span class="hljs-type">A</span>])
        <span class="hljs-keyword">case</span> <span class="hljs-type">Delete</span>(key) =&gt;
          println(<span class="hljs-string">s&quot;delete(<span class="hljs-subst">$key</span>)&quot;</span>)
          kvs.remove(key)
          ()
      }
  }
</code></pre>
<p>Please note this <code>impureCompiler</code> is impure -- it mutates <code>kvs</code> and
also produces logging output using <code>println</code>.  The whole purpose of
functional programming isn&apos;t to prevent side-effects, it is just to
push side-effects to the boundaries of your system in a well-known and
controlled way.</p>
<p><code>Id[_]</code> represents the simplest type container: the type itself. Thus,
<code>Id[Int]</code> is just <code>Int</code>. This means that our program will execute
immediately, and block until the final value can be returned.</p>
<p>However, we could easily use other type containers for different
behavior, such as:</p>
<ul>
<li><code>Future[_]</code> for asynchronous computation</li>
<li><code>List[_]</code> for gathering multiple results</li>
<li><code>Option[_]</code> to support optional results</li>
<li><code>Xor[E, ?]</code> to support failure</li>
<li>a pseudo-random monad to support non-determinism</li>
<li>and so on...</li>
</ul>
<h4 id="5-run-your-program">5. Run your program</h4>
<p>The final step is naturally running your program after compiling it.</p>
<p><code>Free[_]</code> is just a recursive structure that can be seen as sequence
of operations producing other operations. In this way it is similar to
<code>List[_]</code>. We often use folds (e.g. <code>foldRight</code>) to obtain a single
value from a list; this recurses over the structure, combining its
contents.</p>
<p>The idea behind running a <code>Free[_]</code> is exactly the same. We fold the
recursive structure by:</p>
<ul>
<li>consuming each operation.</li>
<li>compiling the operation into our effective language using
<code>impureCompiler</code> (applying its effects if any).</li>
<li>computing next operation.</li>
<li>continue recursively until reaching a <code>Pure</code> state, and returning it.</li>
</ul>
<p>This operation is called <code>Free.foldMap</code>:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldMap</span></span>[<span class="hljs-type">M</span>[_]](f: <span class="hljs-type">FunctionK</span>[<span class="hljs-type">S</span>,<span class="hljs-type">M</span>])(<span class="hljs-type">M</span>: <span class="hljs-type">Monad</span>[<span class="hljs-type">M</span>]): <span class="hljs-type">M</span>[<span class="hljs-type">A</span>] = ...
</code></pre>
<p><code>M</code> must be a <code>Monad</code> to be flattenable (the famous monoid aspect
under <code>Monad</code>). As <code>Id</code> is a <code>Monad</code>, we can use <code>foldMap</code>.</p>
<p>To run your <code>Free</code> with previous <code>impureCompiler</code>:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> result: <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] = program.foldMap(impureCompiler)
<span class="hljs-comment">// put(wild-cats, 2)</span>
<span class="hljs-comment">// get(wild-cats)</span>
<span class="hljs-comment">// put(wild-cats, 14)</span>
<span class="hljs-comment">// put(tame-cats, 5)</span>
<span class="hljs-comment">// get(wild-cats)</span>
<span class="hljs-comment">// delete(tame-cats)</span>
<span class="hljs-comment">// result: Option[Int] = Some(14)</span>
</code></pre>
<p>An important aspect of <code>foldMap</code> is its <strong>stack-safety</strong>. It evaluates
each step of computation on the stack then unstack and restart. This
process is known as trampolining.</p>
<p>As long as your natural transformation is stack-safe, <code>foldMap</code> will
never overflow your stack.  Trampolining is heap-intensive but
stack-safety provides the reliability required to use <code>Free[_]</code> for
data-intensive tasks, as well as infinite processes such as streams.</p>
<h4 id="7-use-a-pure-compiler-optional">7. Use a pure compiler (optional)</h4>
<p>The previous examples used a effectful natural transformation. This
works, but you might prefer folding your <code>Free</code> in a &quot;purer&quot; way. The
<a href="state.html">State</a> data structure can be used to keep track of the program
state in an immutable map, avoiding mutation altogether.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">State</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">KVStoreState</span>[<span class="hljs-type">A</span>] </span>= <span class="hljs-type">State</span>[<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Any</span>], <span class="hljs-type">A</span>]
<span class="hljs-keyword">val</span> pureCompiler: <span class="hljs-type">KVStoreA</span> ~&gt; <span class="hljs-type">KVStoreState</span> = <span class="hljs-keyword">new</span> (<span class="hljs-type">KVStoreA</span> ~&gt; <span class="hljs-type">KVStoreState</span>) {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">KVStoreA</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">KVStoreState</span>[<span class="hljs-type">A</span>] =
    fa <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">Put</span>(key, value) =&gt; <span class="hljs-type">State</span>.modify(_.updated(key, value))
      <span class="hljs-keyword">case</span> <span class="hljs-type">Get</span>(key) =&gt;
        <span class="hljs-type">State</span>.inspect(_.get(key).map(_.asInstanceOf[<span class="hljs-type">A</span>]))
      <span class="hljs-keyword">case</span> <span class="hljs-type">Delete</span>(key) =&gt; <span class="hljs-type">State</span>.modify(_ - key)
    }
}
</code></pre>
<p>(You can see that we are again running into some places where Scala&apos;s
support for pattern matching is limited by the JVM&apos;s type erasure, but
it&apos;s not too hard to get around.)</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> result: (<span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">Any</span>], <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>]) = program.foldMap(pureCompiler).run(<span class="hljs-type">Map</span>.empty).value
<span class="hljs-comment">// result: (Map[String,Any], Option[Int]) = (Map(wild-cats -&gt; 14),Some(14))</span>
</code></pre>
<h2 id="composing-free-monads-adts">Composing Free monads ADTs.</h2>
<p>Real world applications often time combine different algebras.
The <code>Inject</code> type class described by Swierstra in <a href="http://www.staff.science.uu.nl/~swier004/publications/2008-jfp.pdf" _target="blank">Data types &#xE0; la carte</a>
lets us compose different algebras in the context of <code>Free</code>.</p>
<p>Let&apos;s see a trivial example of unrelated ADT&apos;s getting composed as a <code>Coproduct</code> that can form a more complex program.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.{<span class="hljs-type">Xor</span>, <span class="hljs-type">Coproduct</span>}
<span class="hljs-keyword">import</span> cats.free.{<span class="hljs-type">Inject</span>, <span class="hljs-type">Free</span>}
<span class="hljs-keyword">import</span> cats.{<span class="hljs-type">Id</span>, ~&gt;}
<span class="hljs-keyword">import</span> scala.collection.mutable.<span class="hljs-type">ListBuffer</span>
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">/* Handles user interaction */</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Interact</span>[<span class="hljs-type">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ask</span>(<span class="hljs-params">prompt: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Interact</span>[<span class="hljs-type">String</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tell</span>(<span class="hljs-params">msg: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Interact</span>[<span class="hljs-type">Unit</span>]</span>

<span class="hljs-comment">/* Represents persistence operations */</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DataOp</span>[<span class="hljs-type">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddCat</span>(<span class="hljs-params">a: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">DataOp</span>[<span class="hljs-type">Unit</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetAllCats</span>(<span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">DataOp</span>[<span class="hljs-type">List</span>[<span class="hljs-type">String</span>]]</span>
</code></pre>
<p>Once the ADTs are defined we can formally state that a <code>Free</code> program is the Coproduct of it&apos;s Algebras.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">CatsApp</span>[<span class="hljs-type">A</span>] </span>= <span class="hljs-type">Coproduct</span>[<span class="hljs-type">DataOp</span>, <span class="hljs-type">Interact</span>, <span class="hljs-type">A</span>]
</code></pre>
<p>In order to take advantage of monadic composition we use smart constructors to lift our Algebra to the <code>Free</code> context.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interacts</span>[<span class="hljs-type">F</span>[_]](<span class="hljs-params">implicit <span class="hljs-type">I</span>: <span class="hljs-type">Inject</span>[<span class="hljs-type">Interact</span>, <span class="hljs-type">F</span>]</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell</span></span>(msg: <span class="hljs-type">String</span>): <span class="hljs-type">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-type">Free</span>.inject[<span class="hljs-type">Interact</span>, <span class="hljs-type">F</span>](<span class="hljs-type">Tell</span>(msg))
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ask</span></span>(prompt: <span class="hljs-type">String</span>): <span class="hljs-type">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">String</span>] = <span class="hljs-type">Free</span>.inject[<span class="hljs-type">Interact</span>, <span class="hljs-type">F</span>](<span class="hljs-type">Ask</span>(prompt))
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Interacts</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interacts</span></span>[<span class="hljs-type">F</span>[_]](<span class="hljs-keyword">implicit</span> <span class="hljs-type">I</span>: <span class="hljs-type">Inject</span>[<span class="hljs-type">Interact</span>, <span class="hljs-type">F</span>]): <span class="hljs-type">Interacts</span>[<span class="hljs-type">F</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Interacts</span>[<span class="hljs-type">F</span>]
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSource</span>[<span class="hljs-type">F</span>[_]](<span class="hljs-params">implicit <span class="hljs-type">I</span>: <span class="hljs-type">Inject</span>[<span class="hljs-type">DataOp</span>, <span class="hljs-type">F</span>]</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addCat</span></span>(a: <span class="hljs-type">String</span>): <span class="hljs-type">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-type">Free</span>.inject[<span class="hljs-type">DataOp</span>, <span class="hljs-type">F</span>](<span class="hljs-type">AddCat</span>(a))
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getAllCats</span></span>: <span class="hljs-type">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">List</span>[<span class="hljs-type">String</span>]] = <span class="hljs-type">Free</span>.inject[<span class="hljs-type">DataOp</span>, <span class="hljs-type">F</span>](<span class="hljs-type">GetAllCats</span>())
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">DataSource</span> </span>{
  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataSource</span></span>[<span class="hljs-type">F</span>[_]](<span class="hljs-keyword">implicit</span> <span class="hljs-type">I</span>: <span class="hljs-type">Inject</span>[<span class="hljs-type">DataOp</span>, <span class="hljs-type">F</span>]): <span class="hljs-type">DataSource</span>[<span class="hljs-type">F</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">DataSource</span>[<span class="hljs-type">F</span>]
}
</code></pre>
<p>ADTs are now easily composed and trivially intertwined inside monadic contexts.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">program</span></span>(<span class="hljs-keyword">implicit</span> <span class="hljs-type">I</span> : <span class="hljs-type">Interacts</span>[<span class="hljs-type">CatsApp</span>], <span class="hljs-type">D</span> : <span class="hljs-type">DataSource</span>[<span class="hljs-type">CatsApp</span>]): <span class="hljs-type">Free</span>[<span class="hljs-type">CatsApp</span>, <span class="hljs-type">Unit</span>] = {

  <span class="hljs-keyword">import</span> <span class="hljs-type">I</span>._, <span class="hljs-type">D</span>._

  <span class="hljs-keyword">for</span> {
    cat &lt;- ask(<span class="hljs-string">&quot;What&apos;s the kitty&apos;s name?&quot;</span>)
    _ &lt;- addCat(cat)
    cats &lt;- getAllCats
    _ &lt;- tell(cats.toString)
  } <span class="hljs-keyword">yield</span> ()
}
</code></pre>
<p>Finally we write one interpreter per ADT and combine them with a <code>FunctionK</code> to <code>Coproduct</code> so they can be
compiled and applied to our <code>Free</code> program.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ConsoleCatsInterpreter</span> <span class="hljs-keyword">extends</span> (<span class="hljs-params"><span class="hljs-type">Interact</span> ~&gt; <span class="hljs-type">Id</span></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](i: <span class="hljs-type">Interact</span>[<span class="hljs-type">A</span>]) = i <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Ask</span>(prompt) =&gt;
      println(prompt)
      readLine()
    <span class="hljs-keyword">case</span> <span class="hljs-type">Tell</span>(msg) =&gt;
      println(msg)
  }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">InMemoryDatasourceInterpreter</span> <span class="hljs-keyword">extends</span> (<span class="hljs-params"><span class="hljs-type">DataOp</span> ~&gt; <span class="hljs-type">Id</span></span>) </span>{

  <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>] <span class="hljs-keyword">val</span> memDataSet = <span class="hljs-keyword">new</span> <span class="hljs-type">ListBuffer</span>[<span class="hljs-type">String</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">DataOp</span>[<span class="hljs-type">A</span>]) = fa <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">AddCat</span>(a) =&gt; memDataSet.append(a); ()
    <span class="hljs-keyword">case</span> <span class="hljs-type">GetAllCats</span>() =&gt; memDataSet.toList
  }
}

<span class="hljs-keyword">val</span> interpreter: <span class="hljs-type">CatsApp</span> ~&gt; <span class="hljs-type">Id</span> = <span class="hljs-type">InMemoryDatasourceInterpreter</span> or <span class="hljs-type">ConsoleCatsInterpreter</span>
</code></pre>
<p>Now if we run our program and type in &quot;snuggles&quot; when prompted, we see something like this:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> <span class="hljs-type">DataSource</span>._, <span class="hljs-type">Interacts</span>._
</code></pre>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> evaled: <span class="hljs-type">Unit</span> = program.foldMap(interpreter)
<span class="hljs-comment">// What&apos;s the kitty&apos;s name?</span>
<span class="hljs-comment">// List(snuggles)</span>
<span class="hljs-comment">// evaled: Unit = ()</span>
</code></pre>
<h2 id="for-the-curious-ones-what-is-free-in-theory"><a name="what-is-free-in-theory"></a>For the curious ones: what is Free in theory?</h2>
<p>Mathematically-speaking, a <em>free monad</em> (at least in the programming
language context) is a construction that is left adjoint to a
forgetful functor whose domain is the category of Monads and whose
co-domain is the category of Endofunctors. Huh?</p>
<p>Concretely, <strong>it is just a clever construction that allows us to build a
<em>very simple</em> Monad from any <em>functor</em></strong>.</p>
<p>The above forgetful functor takes a <code>Monad</code> and:</p>
<ul>
<li>forgets its <em>monadic</em> part (e.g. the <code>flatMap</code> function)</li>
<li>forgets its <em>pointed</em> part (e.g. the <code>pure</code> function)</li>
<li>finally keeps the <em>functor</em> part (e.g. the <code>map</code> function)</li>
</ul>
<p>By reversing all arrows to build the left-adjoint, we deduce that the
free monad is basically a construction that:</p>
<ul>
<li>takes a <em>functor</em></li>
<li>adds the <em>pointed</em> part (e.g. <code>pure</code>)</li>
<li>adds the <em>monadic</em> behavior (e.g. <code>flatMap</code>)</li>
</ul>
<p>In terms of implementation, to build a <em>monad</em> from a <em>functor</em> we use
the following classic inductive definition:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Free</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pure</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">A</span>](<span class="hljs-params">a: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">A</span>]</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Suspend</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">A</span>](<span class="hljs-params">a: <span class="hljs-type">F</span>[<span class="hljs-type">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">A</span>]]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Free</span>[<span class="hljs-type">F</span>, <span class="hljs-type">A</span>]</span>
</code></pre>
<p>(<em>This generalizes the concept of fixed point functor</em>.)</p>
<p>In this representation:</p>
<ul>
<li><code>Pure</code> builds a <code>Free</code> instance from an <code>A</code> value (it <em>reifies</em> the
<code>pure</code> function)</li>
<li><code>Suspend</code> build a new <code>Free</code> by applying <code>F</code> to a previous <code>Free</code>
(it <em>reifies</em> the <code>flatMap</code> function)</li>
</ul>
<p>So a typical <code>Free</code> structure might look like:</p>
<pre><code class="lang-scala"><span class="hljs-type">Suspend</span>(<span class="hljs-type">F</span>(<span class="hljs-type">Suspend</span>(<span class="hljs-type">F</span>(<span class="hljs-type">Suspend</span>(<span class="hljs-type">F</span>(....(<span class="hljs-type">Pure</span>(a))))))))
</code></pre>
<p><code>Free</code> is a recursive structure. It uses <code>A</code> in <code>F[A]</code> as the
recursion &quot;carrier&quot; with a terminal element <code>Pure</code>.</p>
<p>From a computational point of view, <code>Free</code> recursive structure can be
seen as a sequence of operations.</p>
<ul>
<li><code>Pure</code> returns an <code>A</code> value and ends the entire computation.</li>
<li><code>Suspend</code> is a continuation; it suspends the current computation
with the suspension functor <code>F</code> (which can represent a command for
example) and hands control to the caller. <code>A</code> represents a value
bound to this computation.</li>
</ul>
<p>Please note this <code>Free</code> construction has the interesting quality of
<em>encoding</em> the recursion on the heap instead of the stack as classic
function calls would. This provides the stack-safety we heard about
earlier, allowing very large <code>Free</code> structures to be evaluated safely.</p>
<h3 id="for-the-very-curious-ones">For the very curious ones</h3>
<p>If you look at implementation in cats, you will see another member of
the <code>Free[_]</code> ADT:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gosub</span>[<span class="hljs-type">S</span>[_], <span class="hljs-title">B</span>](<span class="hljs-params"></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Free</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>] </span>{
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">val</span> a: () =&gt; <span class="hljs-type">Free</span>[<span class="hljs-type">S</span>, <span class="hljs-type">C</span>]
  <span class="hljs-keyword">val</span> f: <span class="hljs-type">C</span> =&gt; <span class="hljs-type">Free</span>[<span class="hljs-type">S</span>, <span class="hljs-type">B</span>]
}
</code></pre>
<p><code>Gosub</code> represents a call to a subroutine <code>a</code> and when <code>a</code> is
finished, it continues the computation by calling the function <code>f</code>
with the result of <code>a</code>.</p>
<p>It is actually an optimization of <code>Free</code> structure allowing to solve a
problem of quadratic complexity implied by very deep recursive <code>Free</code>
computations.</p>
<p>It is exactly the same problem as repeatedly appending to a <code>List[_]</code>.
As the sequence of operations becomes longer, the slower a <code>flatMap</code>
&quot;through&quot; the structure will be. With <code>Gosub</code>, <code>Free</code> becomes a
right-associated structure not subject to quadratic complexity.</p>
<h2 id="future-work-todo">Future Work (TODO)</h2>
<p>There are many remarkable uses of <code>Free[_]</code>. In the future, we will
include some here, such as:</p>
<ul>
<li>Trampoline</li>
<li>Option</li>
<li>Iteratee</li>
<li>Source</li>
<li>etc...</li>
</ul>
<p>We will also discuss the <em>Coyoneda Trick</em>.</p>
<h2 id="credits">Credits</h2>
<p>This article was written by
<a href="https://github.com/mandubian" _target="blank">Pascal Voitot</a> and edited by other
members of the Cats community.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="freeapplicative.html" class="navigation navigation-prev " aria-label="Previous page: Freeapplicative">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="kleisli.html" class="navigation navigation-next " aria-label="Next page: Kleisli">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"layout":"default","title":"Freemonad","section":"data","source":"free/src/main/scala/cats/free/Free.scala","scaladoc":"#cats.free.Free","level":"1.3.3","depth":2,"next":{"title":"Kleisli","level":"1.3.4","depth":2,"path":"kleisli.md","ref":"kleisli.md","articles":[]},"previous":{"title":"Freeapplicative","level":"1.3.2","depth":2,"path":"freeapplicative.md","ref":"freeapplicative.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"freemonad.md","mtime":"2016-06-18T19:52:02.912Z","type":"markdown"},"gitbook":{"version":"3.0.3","time":"2016-06-18T20:02:33.141Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/buttons.js"></script>
        
    

    </body>
</html>

