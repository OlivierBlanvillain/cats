
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>Validated Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.0.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="xor.html" />
    
    
    <link rel="prev" href="state.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="typeclasses.html">
            
                <a href="typeclasses.html">
            
                    
                    Typeclasses
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="applicative.html">
            
                <a href="applicative.html">
            
                    
                    Applicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="apply.html">
            
                <a href="apply.html">
            
                    
                    Apply
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="contravariant.html">
            
                <a href="contravariant.html">
            
                    
                    Contravariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    Faq
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="foldable.html">
            
                <a href="foldable.html">
            
                    
                    Foldable
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="functor.html">
            
                <a href="functor.html">
            
                    
                    Functor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="id.html">
            
                <a href="id.html">
            
                    
                    Id
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="invariant.html">
            
                <a href="invariant.html">
            
                    
                    Invariant
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="monad.html">
            
                <a href="monad.html">
            
                    
                    Monad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="monadcombine.md">
            
                <a href="monadcombine.md">
            
                    
                    Monadcombine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="monadfilter.md">
            
                <a href="monadfilter.md">
            
                    
                    Monadfilter
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="monoid.html">
            
                <a href="monoid.html">
            
                    
                    Monoid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="monoidk.md">
            
                <a href="monoidk.md">
            
                    
                    Monoidk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="semigroup.html">
            
                <a href="semigroup.html">
            
                    
                    Semigroup
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.15" data-path="semigroupk.html">
            
                <a href="semigroupk.html">
            
                    
                    Semigroupk
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.16" data-path="show.md">
            
                <a href="show.md">
            
                    
                    Show
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.17" data-path="traverse.html">
            
                <a href="traverse.html">
            
                    
                    Traverse
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Data Types
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="const.html">
            
                <a href="const.html">
            
                    
                    Const
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="freeapplicative.html">
            
                <a href="freeapplicative.html">
            
                    
                    Freeapplicative
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="freemonad.html">
            
                <a href="freemonad.html">
            
                    
                    Freemonad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="kleisli.html">
            
                <a href="kleisli.html">
            
                    
                    Kleisli
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="oneand.html">
            
                <a href="oneand.html">
            
                    
                    Oneand
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="optiont.html">
            
                <a href="optiont.html">
            
                    
                    Optiont
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="state.html">
            
                <a href="state.html">
            
                    
                    State
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.8" data-path="validated.html">
            
                <a href="validated.html">
            
                    
                    Validated
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="xor.html">
            
                <a href="xor.html">
            
                    
                    Xor
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="CONTRIBUTING.html">
            
                <a href="CONTRIBUTING.html">
            
                    
                    Contributing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="PROCESS.html">
            
                <a href="PROCESS.html">
            
                    
                    Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="AUTHORS.html">
            
                <a href="AUTHORS.html">
            
                    
                    Authors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="CHANGES.html">
            
                <a href="CHANGES.html">
            
                    
                    Changes
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Validated</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="validated">Validated</h1>
<p>Imagine you are filling out a web form to signup for an account. You input your username and password and submit.
Response comes back saying your username can&apos;t have dashes in it, so you make some changes and resubmit. Can&apos;t
have special characters either. Change, resubmit. Passwords need to have at least one capital letter. Change,
resubmit. Password needs to have at least one number.</p>
<p>Or perhaps you&apos;re reading from a configuration file. One could imagine the configuration library you&apos;re using returns
a <code>scala.util.Try</code>, or maybe a <code>scala.util.Either</code> (or <code>cats.data.Xor</code>). Your parsing may look something like:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">for</span> {
  url  &lt;- config[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;url&quot;</span>)
  port &lt;- config[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;port&quot;</span>)
} <span class="hljs-keyword">yield</span> <span class="hljs-type">ConnectionParams</span>(url, port)
</code></pre>
<p>You run your program and it says key &quot;url&quot; not found, turns out the key was &quot;endpoint&quot;. So you change your code
and re-run. Now it says the &quot;port&quot; key was not a well-formed integer.</p>
<p>It would be nice to have all of these errors be reported simultaneously. That the username can&apos;t have dashes can
be validated separately from it not having special characters, as well as from the password needing to have certain
requirements. A misspelled (or missing) field in a config can be validated separately from another field not being
well-formed.</p>
<p>Enter <code>Validated</code>.</p>
<h2 id="parallel-validation">Parallel validation</h2>
<p>Our goal is to report any and all errors across independent bits of data. For instance, when we ask for several
pieces of configuration, each configuration field can be validated separately from one another. How then do we
enforce that the data we are working with is independent? We ask for both of them up front.</p>
<p>As our running example, we will look at config parsing. Our config will be represented by a
<code>Map[String, String]</code>. Parsing will be handled by a <code>Read</code> type class - we provide instances
just for <code>String</code> and <code>Int</code> for brevity.</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Read</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Read</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](<span class="hljs-keyword">implicit</span> <span class="hljs-type">A</span>: <span class="hljs-type">Read</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">Read</span>[<span class="hljs-type">A</span>] = <span class="hljs-type">A</span>

  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> stringRead: <span class="hljs-type">Read</span>[<span class="hljs-type">String</span>] =
    <span class="hljs-keyword">new</span> <span class="hljs-type">Read</span>[<span class="hljs-type">String</span>] { <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Some</span>(s) }

  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> intRead: <span class="hljs-type">Read</span>[<span class="hljs-type">Int</span>] =
    <span class="hljs-keyword">new</span> <span class="hljs-type">Read</span>[<span class="hljs-type">Int</span>] {
      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>(s: <span class="hljs-type">String</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>] =
        <span class="hljs-keyword">if</span> (s.matches(<span class="hljs-string">&quot;-?[0-9]+&quot;</span>)) <span class="hljs-type">Some</span>(s.toInt)
        <span class="hljs-keyword">else</span> <span class="hljs-type">None</span>
    }
}
</code></pre>
<p>Then we enumerate our errors - when asking for a config value, one of two things can
go wrong: the field is missing, or it is not well-formed with regards to the expected
type.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigError</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MissingConfig</span>(<span class="hljs-params">field: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigError</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseError</span>(<span class="hljs-params">field: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigError</span></span>
</code></pre>
<p>We need a data type that can represent either a successful value (a parsed configuration),
or an error.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Validated</span>[+<span class="hljs-type">E</span>, +<span class="hljs-type">A</span>]</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Validated</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Valid</span>[+<span class="hljs-type">A</span>](<span class="hljs-params">a: <span class="hljs-type">A</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Validated</span>[<span class="hljs-type">Nothing</span>, <span class="hljs-type">A</span>]</span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invalid</span>[+<span class="hljs-type">E</span>](<span class="hljs-params">e: <span class="hljs-type">E</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">Nothing</span>]</span>
}
</code></pre>
<p>Now we are ready to write our parser.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Validated</span>
<span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Validated</span>.{<span class="hljs-type">Invalid</span>, <span class="hljs-type">Valid</span>}

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>(<span class="hljs-params">map: <span class="hljs-type">Map</span>[<span class="hljs-type">String</span>, <span class="hljs-type">String</span>]</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span></span>[<span class="hljs-type">A</span> : <span class="hljs-type">Read</span>](key: <span class="hljs-type">String</span>): <span class="hljs-type">Validated</span>[<span class="hljs-type">ConfigError</span>, <span class="hljs-type">A</span>] =
    map.get(key) <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">None</span>        =&gt; <span class="hljs-type">Invalid</span>(<span class="hljs-type">MissingConfig</span>(key))
      <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(value) =&gt;
        <span class="hljs-type">Read</span>[<span class="hljs-type">A</span>].read(value) <span class="hljs-keyword">match</span> {
          <span class="hljs-keyword">case</span> <span class="hljs-type">None</span>    =&gt; <span class="hljs-type">Invalid</span>(<span class="hljs-type">ParseError</span>(key))
          <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(a) =&gt; <span class="hljs-type">Valid</span>(a)
        }
    }
}
</code></pre>
<p>Everything is in place to write the parallel validator. Recall that we can only do parallel
validation if each piece is independent. How do we enforce the data is independent? By asking
for all of it up front. Let&apos;s start with two pieces of data.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parallelValidate</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](v1: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>], v2: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">C</span>] =
  (v1, v2) <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Valid</span>(a), <span class="hljs-type">Valid</span>(b))       =&gt; <span class="hljs-type">Valid</span>(f(a, b))
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Valid</span>(_), i<span class="hljs-meta">@Invalid</span>(_))   =&gt; i
    <span class="hljs-keyword">case</span> (i<span class="hljs-meta">@Invalid</span>(_), <span class="hljs-type">Valid</span>(_))   =&gt; i
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Invalid</span>(e1), <span class="hljs-type">Invalid</span>(e2)) =&gt; ???
  }
</code></pre>
<p>We&apos;ve run into a problem. In the case where both have errors, we want to report both. But we have
no way of combining the two errors into one error! Perhaps we can put both errors into a <code>List</code>,
but that seems needlessly specific - clients may want to define their own way of combining errors.</p>
<p>How then do we abstract over a binary operation? The <code>Semigroup</code> type class captures this idea.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Semigroup</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parallelValidate</span></span>[<span class="hljs-type">E</span> : <span class="hljs-type">Semigroup</span>, <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](v1: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>], v2: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">C</span>] =
  (v1, v2) <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Valid</span>(a), <span class="hljs-type">Valid</span>(b))       =&gt; <span class="hljs-type">Valid</span>(f(a, b))
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Valid</span>(_), i<span class="hljs-meta">@Invalid</span>(_))   =&gt; i
    <span class="hljs-keyword">case</span> (i<span class="hljs-meta">@Invalid</span>(_), <span class="hljs-type">Valid</span>(_))   =&gt; i
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Invalid</span>(e1), <span class="hljs-type">Invalid</span>(e2)) =&gt; <span class="hljs-type">Invalid</span>(<span class="hljs-type">Semigroup</span>[<span class="hljs-type">E</span>].combine(e1, e2))
  }
</code></pre>
<p>Perfect! But.. going back to our example, we don&apos;t have a way to combine <code>ConfigError</code>s. But as clients,
we can change our <code>Validated</code> values where the error can be combined, say, a <code>List[ConfigError]</code>. It is
more common however to use a <code>NonEmptyList[ConfigError]</code> - the <code>NonEmptyList</code> statically guarantees we
have at least one value, which aligns with the fact that if we have an <code>Invalid</code>, then we most
certainly have at least one error. This technique is so common there is a convenient method on <code>Validated</code>
called <code>toValidatedNel</code> that turns any <code>Validated[E, A]</code> value to a <code>Validated[NonEmptyList[E], A]</code>.
Additionally, the type alias <code>ValidatedNel[E, A]</code> is provided.</p>
<p>Time to parse.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">SemigroupK</span>
<span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">NonEmptyList</span>
<span class="hljs-keyword">import</span> cats.implicits._

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionParams</span>(<span class="hljs-params">url: <span class="hljs-type">String</span>, port: <span class="hljs-type">Int</span></span>)</span>

<span class="hljs-keyword">val</span> config = <span class="hljs-type">Config</span>(<span class="hljs-type">Map</span>((<span class="hljs-string">&quot;endpoint&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>), (<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;not an int&quot;</span>)))

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> nelSemigroup: <span class="hljs-type">Semigroup</span>[<span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">ConfigError</span>]] =
  <span class="hljs-type">SemigroupK</span>[<span class="hljs-type">NonEmptyList</span>].algebra[<span class="hljs-type">ConfigError</span>]

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> readString: <span class="hljs-type">Read</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">Read</span>.stringRead
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> readInt: <span class="hljs-type">Read</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Read</span>.intRead
</code></pre>
<p>Any and all errors are reported!</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v1 = parallelValidate(config.parse[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;url&quot;</span>).toValidatedNel,
                          config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;port&quot;</span>).toValidatedNel)(<span class="hljs-type">ConnectionParams</span>.apply)
<span class="hljs-comment">// v1: cats.data.Validated[cats.data.NonEmptyList[ConfigError],ConnectionParams] = Invalid(OneAnd(MissingConfig(url),List(ParseError(port))))</span>

<span class="hljs-keyword">val</span> v2 = parallelValidate(config.parse[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;endpoint&quot;</span>).toValidatedNel,
                          config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;port&quot;</span>).toValidatedNel)(<span class="hljs-type">ConnectionParams</span>.apply)
<span class="hljs-comment">// v2: cats.data.Validated[cats.data.NonEmptyList[ConfigError],ConnectionParams] = Invalid(OneAnd(ParseError(port),List()))</span>

<span class="hljs-keyword">val</span> config = <span class="hljs-type">Config</span>(<span class="hljs-type">Map</span>((<span class="hljs-string">&quot;endpoint&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>), (<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>)))
<span class="hljs-comment">// config: Config = Config(Map(endpoint -&gt; 127.0.0.1, port -&gt; 1234))</span>

<span class="hljs-keyword">val</span> v3 = parallelValidate(config.parse[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;endpoint&quot;</span>).toValidatedNel,
                          config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;port&quot;</span>).toValidatedNel)(<span class="hljs-type">ConnectionParams</span>.apply)
<span class="hljs-comment">// v3: cats.data.Validated[cats.data.NonEmptyList[ConfigError],ConnectionParams] = Valid(ConnectionParams(127.0.0.1,1234))</span>
</code></pre>
<h2 id="apply">Apply</h2>
<p>Our <code>parallelValidate</code> function looks awfully like the <code>Apply#map2</code> function.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map2</span></span>[<span class="hljs-type">F</span>[_], <span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>], fb: <span class="hljs-type">F</span>[<span class="hljs-type">B</span>])(f: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>): <span class="hljs-type">F</span>[<span class="hljs-type">C</span>]
</code></pre>
<p>Which can be defined in terms of <code>Apply#ap</code> and <code>Apply#map</code>, the very functions needed to create an <code>Apply</code> instance.</p>
<p>Can we perhaps define an <code>Apply</code> instance for <code>Validated</code>? Better yet, can we define an <code>Applicative</code> instance?</p>
<p><em>Note</em>: the example below assumes usage of the <a href="https://github.com/non/kind-projector" _target="blank">kind-projector compiler plugin</a> and will not compile if it is not being used in a project.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Applicative</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validatedApplicative</span></span>[<span class="hljs-type">E</span> : <span class="hljs-type">Semigroup</span>]: <span class="hljs-type">Applicative</span>[<span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, ?]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Applicative</span>[<span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, ?]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>])(fa: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>] =
      (fa, f) <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> (<span class="hljs-type">Valid</span>(a), <span class="hljs-type">Valid</span>(fab)) =&gt; <span class="hljs-type">Valid</span>(fab(a))
        <span class="hljs-keyword">case</span> (i<span class="hljs-meta">@Invalid</span>(_), <span class="hljs-type">Valid</span>(_)) =&gt; i
        <span class="hljs-keyword">case</span> (<span class="hljs-type">Valid</span>(_), i<span class="hljs-meta">@Invalid</span>(_)) =&gt; i
        <span class="hljs-keyword">case</span> (<span class="hljs-type">Invalid</span>(e1), <span class="hljs-type">Invalid</span>(e2)) =&gt; <span class="hljs-type">Invalid</span>(<span class="hljs-type">Semigroup</span>[<span class="hljs-type">E</span>].combine(e1, e2))
      }

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](x: <span class="hljs-type">A</span>): <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Validated</span>.valid(x)
  }
</code></pre>
<p>Awesome! And now we also get access to all the goodness of <code>Applicative</code>, which includes <code>map{2-22}</code>, as well as the
<code>Cartesian</code> syntax <code>|@|</code>.</p>
<p>We can now easily ask for several bits of configuration and get any and all errors returned back.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Apply</span>
<span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">ValidatedNel</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> nelSemigroup: <span class="hljs-type">Semigroup</span>[<span class="hljs-type">NonEmptyList</span>[<span class="hljs-type">ConfigError</span>]] =
  <span class="hljs-type">SemigroupK</span>[<span class="hljs-type">NonEmptyList</span>].algebra[<span class="hljs-type">ConfigError</span>]

<span class="hljs-keyword">val</span> config = <span class="hljs-type">Config</span>(<span class="hljs-type">Map</span>((<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>), (<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;not a number&quot;</span>), (<span class="hljs-string">&quot;houseNumber&quot;</span>, <span class="hljs-string">&quot;1234&quot;</span>), (<span class="hljs-string">&quot;lane&quot;</span>, <span class="hljs-string">&quot;feline street&quot;</span>)))

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>(<span class="hljs-params">houseNumber: <span class="hljs-type">Int</span>, street: <span class="hljs-type">String</span></span>)</span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>, address: <span class="hljs-type">Address</span></span>)</span>
</code></pre>
<p>Thus.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> personFromConfig: <span class="hljs-type">ValidatedNel</span>[<span class="hljs-type">ConfigError</span>, <span class="hljs-type">Person</span>] =
  <span class="hljs-type">Apply</span>[<span class="hljs-type">ValidatedNel</span>[<span class="hljs-type">ConfigError</span>, ?]].map4(config.parse[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;name&quot;</span>).toValidatedNel,
                                           config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;age&quot;</span>).toValidatedNel,
                                           config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;house_number&quot;</span>).toValidatedNel,
                                           config.parse[<span class="hljs-type">String</span>](<span class="hljs-string">&quot;street&quot;</span>).toValidatedNel) {
    <span class="hljs-keyword">case</span> (name, age, houseNumber, street) =&gt; <span class="hljs-type">Person</span>(name, age, <span class="hljs-type">Address</span>(houseNumber, street))
  }
<span class="hljs-comment">// personFromConfig: cats.data.ValidatedNel[ConfigError,Person] = Invalid(OneAnd(MissingConfig(street),List(MissingConfig(house_number), ParseError(age))))</span>
</code></pre>
<h2 id="of-flatmaps-and-xors">Of <code>flatMap</code>s and <code>Xor</code>s</h2>
<p><code>Option</code> has <code>flatMap</code>, <code>Xor</code> has <code>flatMap</code>, where&apos;s <code>Validated</code>&apos;s? Let&apos;s try to implement it - better yet,
let&apos;s implement the <code>Monad</code> type class.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.<span class="hljs-type">Monad</span>

<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validatedMonad</span></span>[<span class="hljs-type">E</span>]: <span class="hljs-type">Monad</span>[<span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, ?]] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Monad</span>[<span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, ?]] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">B</span>] =
      fa <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Valid</span>(a)     =&gt; f(a)
        <span class="hljs-keyword">case</span> i<span class="hljs-meta">@Invalid</span>(_) =&gt; i
      }

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](x: <span class="hljs-type">A</span>): <span class="hljs-type">Validated</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">Valid</span>(x)
  }
</code></pre>
<p>Note that all <code>Monad</code> instances are also <code>Applicative</code> instances, where <code>ap</code> is defined as</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Monad</span>[<span class="hljs-type">F</span>[_]] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](x: <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>] =
    flatMap(fa)(f.andThen(pure))

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">F</span>[<span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>] =
    flatMap(fa)(a =&gt; map(f)(fab =&gt; fab(a)))
}
</code></pre>
<p>However, the <code>ap</code> behavior defined in terms of <code>flatMap</code> does not behave the same as that of
our <code>ap</code> defined above. Observe:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> v = validatedMonad.tuple2(<span class="hljs-type">Validated</span>.invalidNel[<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>](<span class="hljs-string">&quot;oops&quot;</span>), <span class="hljs-type">Validated</span>.invalidNel[<span class="hljs-type">String</span>, <span class="hljs-type">Double</span>](<span class="hljs-string">&quot;uh oh&quot;</span>))
<span class="hljs-comment">// v: cats.data.Validated[cats.data.NonEmptyList[String],(Int, Double)] = Invalid(OneAnd(oops,List()))</span>
</code></pre>
<p>This one short circuits! Therefore, if we were to define a <code>Monad</code> (or <code>FlatMap</code>) instance for <code>Validated</code> we would
have to override <code>ap</code> to get the behavior we want. But then the behavior of <code>flatMap</code> would be inconsistent with
that of <code>ap</code>, not good. Therefore, <code>Validated</code> has only an <code>Applicative</code> instance.</p>
<h2 id="validated-vs-xor"><code>Validated</code> vs <code>Xor</code></h2>
<p>We&apos;ve established that an error-accumulating data type such as <code>Validated</code> can&apos;t have a valid <code>Monad</code> instance. Sometimes the task at hand requires error-accumulation. However, sometimes we want a monadic structure that we can use for sequential validation (such as in a for-comprehension). This leaves us in a bit of a conundrum.</p>
<p>Cats has decided to solve this problem by using separate data structures for error-accumulation (<code>Validated</code>) and short-circuiting monadic behavior (<code>Xor</code>).</p>
<p>If you are trying to decide whether you want to use <code>Validated</code> or <code>Xor</code>, a simple heuristic is to use <code>Validated</code> if you want error-accumulation and to otherwise use <code>Xor</code>.</p>
<h2 id="sequential-validation">Sequential Validation</h2>
<p>If you do want error accumulation but occasionally run into places where you sequential validation is needed, then <code>Validated</code> provides a couple methods that may be helpful.</p>
<h3 id="andthen"><code>andThen</code></h3>
<p>The <code>andThen</code> method is similar to <code>flatMap</code> (such as <code>Xor.flatMap</code>). In the cause of success, it passes the valid value into a function that returns a new <code>Validated</code> instance.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> houseNumber = config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;house_number&quot;</span>).andThen{ n =&gt;
   <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) <span class="hljs-type">Validated</span>.valid(n)
   <span class="hljs-keyword">else</span> <span class="hljs-type">Validated</span>.invalid(<span class="hljs-type">ParseError</span>(<span class="hljs-string">&quot;house_number&quot;</span>))
}
<span class="hljs-comment">// houseNumber: cats.data.Validated[ConfigError,Int] = Invalid(MissingConfig(house_number))</span>
</code></pre>
<h3 id="withxor"><code>withXor</code></h3>
<p>The <code>withXor</code> method allows you to temporarily turn a <code>Validated</code> instance into an <code>Xor</code> instance and apply it to a function.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> cats.data.<span class="hljs-type">Xor</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">positive</span></span>(field: <span class="hljs-type">String</span>, i: <span class="hljs-type">Int</span>): <span class="hljs-type">ConfigError</span> <span class="hljs-type">Xor</span> <span class="hljs-type">Int</span> = {
  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) <span class="hljs-type">Xor</span>.right(i)
  <span class="hljs-keyword">else</span> <span class="hljs-type">Xor</span>.left(<span class="hljs-type">ParseError</span>(field))
}
</code></pre>
<p>Thus.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> houseNumber = config.parse[<span class="hljs-type">Int</span>](<span class="hljs-string">&quot;house_number&quot;</span>).withXor{ xor: <span class="hljs-type">ConfigError</span> <span class="hljs-type">Xor</span> <span class="hljs-type">Int</span> =&gt;
  xor.flatMap{ i =&gt;
    positive(<span class="hljs-string">&quot;house_number&quot;</span>, i)
  }
}
<span class="hljs-comment">// houseNumber: cats.data.Validated[ConfigError,Int] = Invalid(MissingConfig(house_number))</span>
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="state.html" class="navigation navigation-prev " aria-label="Previous page: State">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="xor.html" class="navigation navigation-next " aria-label="Next page: Xor">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"layout":"default","title":"Validated","section":"data","source":"core/src/main/scala/cats/data/Validated.scala","scaladoc":"#cats.data.Validated","level":"1.3.8","depth":2,"next":{"title":"Xor","level":"1.3.9","depth":2,"path":"xor.md","ref":"xor.md","articles":[]},"previous":{"title":"State","level":"1.3.7","depth":2,"path":"state.md","ref":"state.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"validated.md","mtime":"2016-06-18T19:50:42.088Z","type":"markdown"},"gitbook":{"version":"3.0.3","time":"2016-06-18T20:02:33.141Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/buttons.js"></script>
        
    

    </body>
</html>

